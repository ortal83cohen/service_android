package com.hpe.sb.mobile.app.infra.encryption;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.SharedPreferences;
import android.util.Base64;
import android.util.Log;

import com.hpe.sb.mobile.app.infra.exception.EncryptionInitException;
import com.hpe.sb.mobile.app.infra.exception.EncryptionRuntimeException;
import com.hpe.sb.mobile.app.common.utils.LogTagConstants;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.UnrecoverableEntryException;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class EncryptionServiceImpl implements EncryptionService {

    public static final String ENCRYPTION_KEY_NAME = "Key";
    public static final String ENCRYPTION_ALGORITHM = "AES";
    public static final int KEYSIZE = 128;
    public static final String RANDOM_ALGORITHM = "SHA1PRNG";

    private final SecretKeyWrapper secretKeyWrapper;
    private Cipher cipherForEncrypt;
    private Cipher cipherForDecrypt;
    private SecretKey key = null;

    private static final String ENCRYPTION_PREFERENCES_FILE_NAME = "com.hpe.sb.mobile.app.PropelPrivate";

    public EncryptionServiceImpl(SecretKeyWrapper secretKeyWrapper) {
        this.secretKeyWrapper = secretKeyWrapper;
    }

    @SuppressLint("GetInstance") // Fixing lint requires API 23+
    public void init(Context context) {
        try {
            SecretKey key = readEncryptionKeyIfExists(context);
            if (key == null) {
                key = createEncryptionKey();
                storeEncryptionKey(context, key);
            }

            this.key = key;
            cipherForEncrypt = Cipher.getInstance(ENCRYPTION_ALGORITHM);
            cipherForEncrypt.init(Cipher.ENCRYPT_MODE, key);
            cipherForDecrypt = Cipher.getInstance(ENCRYPTION_ALGORITHM);
            cipherForDecrypt.init(Cipher.DECRYPT_MODE, key);
        } catch (InvalidKeyException | InvalidAlgorithmParameterException | NoSuchProviderException |
                UnrecoverableEntryException | NoSuchPaddingException |
                NoSuchAlgorithmException | KeyStoreException e) {
            Log.e(LogTagConstants.ENCRYPTION_SERVICE, "Unable to load keystore or alias, encryption disabled", e);
            throw new EncryptionInitException(e);
        }
    }

    @Override
    public String encrypt(String toEncrypt) {
        String result;
        if (key == null || cipherForEncrypt ==  null) {
            Log.w(LogTagConstants.ENCRYPTION_SERVICE, "Trying to encrypt when key is null");
            throw new EncryptionRuntimeException();
        }

        try {
            byte[] bytes = cipherForEncrypt.doFinal(toEncrypt.getBytes());
            result = Base64.encodeToString(bytes, Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(LogTagConstants.CONNECTION_CONTEXT, "Unable to decrypt, output is not encrypted", e);
            throw new EncryptionRuntimeException(e);
        }

        return result;
    }

    @Override
    public String decrypt(String toDecrypt) {
        String result;
        if (key == null || cipherForDecrypt ==  null) {
            Log.w(LogTagConstants.ENCRYPTION_SERVICE, "Trying to decrypt when key is null");
            throw new EncryptionRuntimeException();
        }

        try {
            byte[] decoded = Base64.decode(toDecrypt, Base64.DEFAULT);
            byte[] decrypted = cipherForDecrypt.doFinal(decoded);
            result = new String(decrypted);
        } catch (Exception e) {
            Log.e(LogTagConstants.CONNECTION_CONTEXT, "Unable to decrypt, output is not decrypted", e);
            throw new EncryptionRuntimeException(e);
        }

        return result;
    }

    private SecretKey createEncryptionKey() throws NoSuchPaddingException,
            NoSuchAlgorithmException, NoSuchProviderException, InvalidAlgorithmParameterException,
            UnrecoverableEntryException, KeyStoreException {
        SecureRandom sr = SecureRandom.getInstance(RANDOM_ALGORITHM);
        KeyGenerator kg = KeyGenerator.getInstance(ENCRYPTION_ALGORITHM);
        kg.init(KEYSIZE, sr);
        return new SecretKeySpec((kg.generateKey()).getEncoded(), "AES");
    }

    /**
     * Stores the symmetric encryption key (Generated by this class), encrypted by an asymmetric
     * key (generated by SecretKeyWrapper). This enables storing a symmetric encryption key
     * in shared preferences without being vulnerable if it's exposed.
     */
    private void storeEncryptionKey(Context context, SecretKey key) {
        if (key == null) {
            Log.w(LogTagConstants.ENCRYPTION_SERVICE, "No encryption key to store");
            return;
        }

        byte[] toStore = secretKeyWrapper.wrap(key);
        String toStoreString = Base64.encodeToString(toStore, Base64.DEFAULT);
        SharedPreferences sharedPreferences = context.getSharedPreferences(ENCRYPTION_PREFERENCES_FILE_NAME,
                Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = sharedPreferences.edit();
        editor.putString(ENCRYPTION_KEY_NAME, toStoreString);
        editor.apply();
    }

    private SecretKey readEncryptionKeyIfExists(Context context) {
        SharedPreferences sharedPreferences = context.getSharedPreferences(ENCRYPTION_PREFERENCES_FILE_NAME,
                Context.MODE_PRIVATE);
        String keyString = sharedPreferences.getString(ENCRYPTION_KEY_NAME, null);
        if (keyString != null) {
            byte[] keyBytes = Base64.decode(keyString, Base64.DEFAULT);
            Log.d(LogTagConstants.ENCRYPTION_SERVICE, "Encryption key retrieved from preferences successfully");
            return secretKeyWrapper.unwrap(keyBytes, ENCRYPTION_ALGORITHM);
        } else {
            Log.d(LogTagConstants.ENCRYPTION_SERVICE, "No Encryption key found");
            return null;
        }
    }
}
